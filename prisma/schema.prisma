generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model cron {
  id        Int         @id @default(autoincrement())
  timing    cron_timing @default(WEEKLY)
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt
}

model failedCronLinks {
  id       Int      @id @default(autoincrement())
  linkId   Int
  hashedUrl String
  timing   links_timing
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  links    links    @relation(fields: [linkId], references: [id], map: "FailedCronLinks_linkId_fkey")
  @@index([linkId], map: "FailedCronLinks_linkId_fkey")
  @@index([hashedUrl], map: "FailedCronLinks_hashedUrl_idx")
  
}
model cronhistory {
  id            Int                @id @default(autoincrement())
  links         Json
  data          Json
  status        cronhistory_status @default(PENDING)
  startTime     DateTime?
  endTime       DateTime?
  failureReason String?
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt
}

model domains {
  id                 Int                        @id @default(autoincrement())
  name               String?
  domain             String                     @unique(map: "Domains_domain_key")
  isActive           Boolean                    @default(true)
  status             domains_status             @default(NOT_CONFIGURED)
  storeImages        Boolean                    @default(false)
  priceElement       Json                       @default("{}")
  priceElementStatus domains_priceElementStatus @default(NOT_FOUND)
  createdAt          DateTime                   @default(now())
  updatedAt          DateTime                   @updatedAt
  domainImage        String?
  includeParams      Boolean                    @default(true)
  links              links[]
  userdomainmap      userdomainmap[]

  @@index([domain], map: "Domains_domain_idx")
}

model linkdata {
  id            Int             @id @default(autoincrement())
  status        linkdata_status @default(PENDING)
  images        Json
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
  failedReason  String?
  hashedUrl     String
  metadata      Json
  htmlObjectKey String          @db.LongText
  screenshotKey String          @db.LongText
  thumbnailKey  String          @db.LongText
  timing        links_timing
  bookmarks     Bookmarks[]
  links         links           @relation(fields: [hashedUrl], references: [hashedUrl], map: "LinkData_linkId_fkey")

  @@unique([hashedUrl, createdAt], map: "LinkData_hashedUrl_createdAt_key")
  @@index([createdAt], map: "LinkData_createdAt_idx")
  @@index([hashedUrl], map: "LinkData_hashedUrl_idx")
}

model links {
  id                 Int           @id @default(autoincrement())
  url                String        @db.LongText
  hashedUrl          String        @unique(map: "Links_hashedUrl_key") //With params
  params             String?
  isActive           Boolean       @default(true)
  trackingImage      Boolean       @default(false)
  imageUrl           String?
  hasConfigChanged   Boolean       @default(false)
  timing             links_timing  @default(WEEKLY)
  domainId           Int
  createdAt          DateTime      @default(now())
  updatedAt          DateTime      @updatedAt
  enablePriceTracker Boolean       @default(false)
  domains            domains       @relation(fields: [domainId], references: [id], map: "Links_domainId_fkey")
  userlinkmap        userlinkmap[]
  linkdata           linkdata[]
  failedCronLinks    failedCronLinks[]
  @@index([domainId], map: "Links_domainId_idx")
  @@index([hashedUrl], map: "Links_hashedUrl_idx")
  @@index([isActive])
}

model organization {
  id        Int      @id @default(autoincrement())
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  creatorId String   @unique(map: "Organization_creatorId_key")
  user      User     @relation(fields: [creatorId], references: [id], map: "Organization_creatorId_fkey")
}

model User {
  id            String          @id @default(cuid())
  name          String?
  email         String          @unique
  emailVerified DateTime?
  image         String?
  accounts      Account[]
  sessions      Session[]
  password      String?
  role          user_role       @default(USER)
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
  organization  organization?
  userlinkmap   userlinkmap[]
  userdomainmap userdomainmap[]
  Notifications Notifications[]
  Bookmarks     Bookmarks[]
}

model userlinkmap {
  id           Int                @id @default(autoincrement())
  assignedName String
  tags         String?
  userId       String
  linkId       Int
  timing       userlinkmap_timing @default(WEEKLY)
  createdAt    DateTime           @default(now())
  updatedAt    DateTime           @updatedAt
  links        links              @relation(fields: [linkId], references: [id], map: "UserLinkMap_linkId_fkey")
  user         User               @relation(fields: [userId], references: [id], map: "UserLinkMap_userId_fkey")

  @@unique([userId, linkId], map: "UserLinkMap_userId_linkId_key")
  @@index([linkId], map: "UserLinkMap_linkId_fkey")
  @@index([userId, linkId], map: "UserLinkMap_userId_linkId_idx")
}

model Notifications {
  id          Int                   @id @default(autoincrement())
  userId      String
  message     String
  description String?
  extraData   Json?
  readStatus  Boolean               @default(false)
  priority    Notification_Priority @default(LOW)
  createdAt   DateTime              @default(now())
  updatedAt   DateTime              @updatedAt
  user        User                  @relation(fields: [userId], references: [id], map: "Notifications_userId_fkey")
  @@index([userId], map: "Notifications_userId_fkey")

}

enum Notification_Priority {
  HIGH
  LOW
}

enum cron_timing {
  HOURLY
  DAILY
  WEEKLY
  MONTHLY
}

enum linkdata_status {
  SUCCESS
  FAILED
  PENDING
  CRON_FAILED
}

enum token_type {
  ACCESS
  REFRESH
  RESET_PASSWORD
  VERIFY_EMAIL
}

enum cronhistory_status {
  SUCCESS
  PENDING
  FAILED
}

enum domains_status {
  CONFIGURED
  NOT_CONFIGURED
  EXCLUDED
}

enum user_role {
  USER
  ADMIN
}

enum userlinkmap_timing {
  HOURLY
  DAILY
  WEEKLY
  MONTHLY
}

enum domains_priceElementStatus {
  SINGLE
  MULTIPLE
  NOT_FOUND
}

enum links_timing {
  HOURLY
  DAILY
  WEEKLY
  MONTHLY
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationRequest {
  id         String   @id @default(cuid())
  identifier String
  token      String   @unique
  expires    DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([identifier, token])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model userdomainmap {
  id        Int      @id @default(autoincrement())
  userId    String
  domainId  Int
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], map: "UserDomainMap_userId_fkey")
  domains   domains  @relation(fields: [domainId], references: [id], map: "UserDomainMap_domainId_fkey")

  @@unique([userId, domainId], map: "UserDomainMap_userId_domainId_key")
  @@index([domainId], map: "UserDomainMap_domainId_fkey")
  @@index([userId, domainId], map: "UserDomainMap_userId_domainId_idx")
}

model Bookmarks {
  id         Int      @id @default(autoincrement())
  userId     String
  linkDataId Int
  linkdata   linkdata @relation(fields: [linkDataId], references: [id], map: "Bookmarks_linkDataId_fkey")
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  user       User     @relation(fields: [userId], references: [id], map: "Bookmarks_userId_fkey")
  isDeleted  Boolean  @default(false)

  @@unique([userId, linkDataId], map: "Bookmarks_userId_linkDataId_key")
  @@index([linkDataId], map: "Bookmarks_linkDataId_fkey")
  @@index([userId])
}
