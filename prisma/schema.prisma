generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model cron {
  id        Int         @id @default(autoincrement())
  timing    cron_timing @default(WEEKLY)
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt
}

model cronhistory {
  id            Int                @id @default(autoincrement())
  links         Json
  data          Json
  status        cronhistory_status @default(PENDING)
  startTime     DateTime?
  endTime       DateTime?
  failureReason String?
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt
}

model domains {
  id                 Int                        @id @default(autoincrement())
  name               String?
  domain             String                     @unique(map: "Domains_domain_key")
  isActive           Boolean                    @default(true)
  status             domains_status             @default(NOT_CONFIGURED)
  storeImages        Boolean                    @default(false)
  priceElement       Json                       @default("{}")
  priceElementStatus domains_priceElementStatus @default(NOT_FOUND)
  createdAt          DateTime                   @default(now())
  updatedAt          DateTime                   @updatedAt
  domainImage        String?
  includeParams      Boolean                    @default(true)
  links              links[]
  userdomainmap      userdomainmap[]
  @@index([domain], map: "Domains_domain_idx")
}

model linkdata {
  id           Int             @id @default(autoincrement())
  status       linkdata_status @default(PENDING)
  images       Json
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt
  failedReason String?
  hashedUrl    String
  metadata     Json
  htmlObjectKey    String          @db.LongText
  screenshotKey    String          @db.LongText
  thumbnailKey     String          @db.LongText
  timing       links_timing    
  @@unique([hashedUrl, createdAt], map: "LinkData_hashedUrl_createdAt_key")
  @@index([createdAt], map: "LinkData_createdAt_idx")
  @@index([hashedUrl], map: "LinkData_hashedUrl_idx")
}

model links {
  id               Int           @id @default(autoincrement())
  url              String        @db.LongText
  hashedUrl        String        @unique(map: "Links_hashedUrl_key") //With params
  params           String?
  isActive         Boolean       @default(true)
  trackingImage    Boolean       @default(false)
  imageUrl         String?
  hasConfigChanged Boolean       @default(false)
  timing           links_timing  @default(WEEKLY)
  domainId         Int
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt
  domains          domains       @relation(fields: [domainId], references: [id], map: "Links_domainId_fkey")
  userlinkmap      userlinkmap[]

  @@index([domainId], map: "Links_domainId_idx")
  @@index([hashedUrl], map: "Links_hashedUrl_idx")
  @@index([isActive])
}

model organization {
  id        Int      @id @default(autoincrement())
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  creatorId String   @unique(map: "Organization_creatorId_key")
  user      User     @relation(fields: [creatorId], references: [id], map: "Organization_creatorId_fkey")
}

model User {
  id            String          @id @default(cuid())
  name          String?
  email         String          @unique
  emailVerified DateTime?
  image         String?
  accounts      Account[]
  sessions      Session[]
  password      String?
  role          user_role       @default(USER)
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
  organization  organization?
  userlinkmap   userlinkmap[]
  userdomainmap userdomainmap[]
  Notifications Notifications[]
}

model userlinkmap {
  id           Int                @id @default(autoincrement())
  assignedName String?
  tags         String?
  userId       String
  linkId       Int
  timing       userlinkmap_timing @default(WEEKLY)
  createdAt    DateTime           @default(now())
  updatedAt    DateTime           @updatedAt
  links        links              @relation(fields: [linkId], references: [id], map: "UserLinkMap_linkId_fkey")
  user         User               @relation(fields: [userId], references: [id], map: "UserLinkMap_userId_fkey")

  @@unique([userId, linkId], map: "UserLinkMap_userId_linkId_key")
  @@index([linkId], map: "UserLinkMap_linkId_fkey")
  @@index([userId, linkId], map: "UserLinkMap_userId_linkId_idx")
}

model Notifications {
  id          Int                   @id @default(autoincrement())
  userId      String
  message     String
  description String?
  readStatus  Boolean               @default(false)
  priority    Notification_Priority @default(LOW)
  createdAt   DateTime              @default(now())
  updatedAt   DateTime              @updatedAt
  user        User                  @relation(fields: [userId], references: [id], map: "Notifications_userId_fkey")
}

enum Notification_Priority {
  HIGH
  LOW
}

enum cron_timing {
  HOURLY
  DAILY
  WEEKLY
  MONTHLY
}

enum linkdata_status {
  SUCCESS
  FAILED
  PENDING
  CRON_FAILED
}

enum token_type {
  ACCESS
  REFRESH
  RESET_PASSWORD
  VERIFY_EMAIL
}

enum cronhistory_status {
  SUCCESS
  PENDING
  FAILED
}

enum domains_status {
  CONFIGURED
  NOT_CONFIGURED
  EXCLUDED
}

enum user_role {
  USER
  ADMIN
}

enum userlinkmap_timing {
  HOURLY
  DAILY
  WEEKLY
  MONTHLY
}

enum domains_priceElementStatus {
  SINGLE
  MULTIPLE
  NOT_FOUND
}

enum links_timing {
  HOURLY
  DAILY
  WEEKLY
  MONTHLY
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationRequest {
  id         String   @id @default(cuid())
  identifier String
  token      String   @unique
  expires    DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([identifier, token])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model userdomainmap {
  id        Int      @id @default(autoincrement())
  userId    String
  domainId  Int
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], map: "UserDomainMap_userId_fkey")
  domains   domains  @relation(fields: [domainId], references: [id], map: "UserDomainMap_domainId_fkey")

  @@unique([userId, domainId], map: "UserDomainMap_userId_domainId_key")
  @@index([domainId], map: "UserDomainMap_domainId_fkey")
  @@index([userId, domainId], map: "UserDomainMap_userId_domainId_idx")
}